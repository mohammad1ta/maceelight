'use strict';

const EventEmitter = require('events');
const msgpack = require('msgpack-lite');
const {
    encodeStream$,
    decodeStream$,
    socket$,
    isClosed$,
    socketEventsTransfer
} = require('./constants.js');

class MsgpackSock extends EventEmitter {
    static wrap(socket, codec) {
        return new MsgpackSock(socket, codec);
    }

    static createConnectionHandler(callback, codec) {
        return function connectionHandler(socket) {
            callback(new MsgpackSock(socket, codec));
        };
    }

    static createCodec() {
        return msgpack.createCodec.apply(msgpack, arguments);
    }

    static encode() {
        return msgpack.encode.apply(msgpack, arguments);
    }

    static decode() {
        return msgpack.decode.apply(msgpack, arguments);
    }

    constructor(socket, codec) {
        super();
        if(codec) {
            this[encodeStream$] = msgpack.createEncodeStream({codec});
            this[decodeStream$] = msgpack.createDecodeStream({codec});
        } else {
            this[encodeStream$] = msgpack.createEncodeStream();
            this[decodeStream$] = msgpack.createDecodeStream();
        }
        const encodeStream = this[encodeStream$];
        const decodeStream = this[decodeStream$];
        this[socket$] = socket;
        encodeStream.pipe(socket);
        socket.pipe(decodeStream);
        decodeStream.on('data', msg => this.emit('message', msg));
        decodeStream.on('end', () => this.close());
        socket.on('close', () => this.close());
        socketEventsTransfer.forEach(event => {
            socket.on(event, (...args) => this.emit(event, ...args));
        });
        encodeStream.on('error', err => this.emit('error', err));
        decodeStream.on('error', err => this.emit('error', err));
        this.once('close', () => {
            this[isClosed$] = true;
            this[encodeStream$].removeAllListeners();
            this[decodeStream$].removeAllListeners();
            this[socket$].removeAllListeners();
            this[encodeStream$] = null;
            this[decodeStream$] = null;
            this[socket$] = null;
        });
        this[isClosed$] = false;
    }

    send(msg) {
        if(this[isClosed$]) {
            throw new Error('Send message after close');
        }
        const encodeStream = this[encodeStream$];
        encodeStream.write(msg);
        encodeStream._flush();
        return this;
    }

    close() {
        if(this[isClosed$]) { return; }
        this[isClosed$] = true;
        this.removeAllListeners('message');
        this[encodeStream$].end();
        this.emit('close');
    }

    address() {
        return this[socket$].address();
    }

    setKeepAlive() {
        return this[socket$].setKeepAlive(...arguments);
    }

    setNoDelay() {
        return this[socket$].setNoDelay(...arguments);
    }

    setTimeout() {
        return this[socket$].setTimeout(...arguments);
    }

    ref() {
        return this[socket$].ref(...arguments);
    }

    unref() {
        return this[socket$].unref(...arguments);
    }

    getCipher() {
        if(!this[socket$].encrypted) {
            return null;
        }
        return this[socket$].getCipher(...arguments);
    }

    getEphemeralKeyInfo() {
        if(!this[socket$].encrypted) {
            return null;
        }
        return this[socket$].getEphemeralKeyInfo(...arguments);
    }

    getPeerCertificate() {
        if(!this[socket$].encrypted) {
            return null;
        }
        return this[socket$].getPeerCertificate(...arguments);
    }

    getProtocol() {
        if(!this[socket$].encrypted) {
            return 'unknown';
        }
        return this[socket$].getProtocol(...arguments);
    }

    getSession() {
        if(!this[socket$].encrypted) {
            return;
        }
        return this[socket$].getSession(...arguments);
    }

    getTLSTicket() {
        if(!this[socket$].encrypted) {
            return;
        }
        return this[socket$].getTLSTicket(...arguments);
    }

    renegotiate() {
        if(!this[socket$].encrypted) {
            return;
        }
        return this[socket$].renegotiate(...arguments);
    }

    setMaxSendFragment() {
        if(!this[socket$].encrypted) {
            return;
        }
        return this[socket$].setMaxSendFragment(...arguments);
    }

    get encrypted() {
        return !!this[socket$].encrypted;
    }

    get authorized() {
        return !!this[socket$].authorized;
    }

    get bytesRead() {
        return this[socket$].bytesRead;
    }

    get bytesWritten() {
        return this[socket$].bytesWritten;
    }

    get localAddress() {
        return this[socket$].localAddress;
    }

    get localPort() {
        return this[socket$].localPort;
    }

    get remoteAddress() {
        return this[socket$].remoteAddress;
    }

    get remoteFamily() {
        return this[socket$].remoteFamily;
    }

    get remotePort() {
        return this[socket$].remotePort;
    }
}

module.exports = MsgpackSock;
